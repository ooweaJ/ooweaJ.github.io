---
title: 유니티3D - 6
date: 2025-06-09 15:00:00 +09:00
categories: [유니티,3D]
tags:
  [
    유니티, 3D
  ]
---
## 이번 목표
액션 구조 정리, AI 기본 이동

### 구조 정리
일단 문제였던 애니메이션 델리게이트 부분에서 무기를 장착할 때 보다는 무기를 WeaponComponent에 넣었을 때 즉 무기를 획득했을 때 구독을 하기로 하자  
그리고 게임 내에서 UI로 무기를 교체할 것인지 , 주어서 교체할 것인지 생각해봐야한다.  
내가 원하는 최종 결과물은 AI에게도 총이 있어 그 소굴을 클리어하는것이 목표니 주어서 사용이 일단 일반적이다.  
UI와도 상호작용 가능하게 첫 무기는 선택이 가능하도록 하겠다. 결론은 둘다 구현을 하는 방향으로 생각해보자..  

- 애니메이션 구도 순서 사진

애니메이터에 파이어트리거는 하나고 피스톨과 주무기를 구분해야한다. 이럴때 AnimatorOverrideController 이용하는 방법이 있는 거 같다.

### AI 기본 이동 (BT)
일단 AI BT를 만들어서 간단하게 플레이어를 인식하는지 실행 시켜보자.  
유니티에서는 패키지 관리자 - 유니티 레지스트리리 - Behavior 설치해줘야한다.  
그럼 생성창에 Behavior가 나오고 BT와 BB를 만들어주자.  
여기서 Actio에 patrol을 추가하고 BB에 게임오브젝트 리스트 변수를 추가한다.  
그리고 AI를 이동시키려면 사용할 메쉬에 NavMesh Surface 컴포넌트를 추가후 베이크 시킨다. 그럼 파랗게 메쉬볼륨이 보일 것  
그 후 리스트에 변수를 넣어서 이동시켜봤다. 잘 이동된다 하지만 순서대로 0 -> 1 -> 2 -> 0 이런식으로 이동한다.  
정방향만 되는것이다 역방향도 가능하게 수정하려면 patrol 액션을 이용하면 안될거같다.  
그래서 NavMeshAgent를 이용해 목표를 향해 이동하면 깔끔할거같다. 목표 설정하는 Action을 만들어 구현해보자.

- 코드 구현 Ai 컨트롤러와 Action 노드 코드

일단 컨트롤러에서 Agent를 이용한 이동코드를 구현한다.
```c#
using UnityEngine;
using UnityEngine.AI;
using Unity.Behavior;

public class AIController : MonoBehaviour
{
    private BehaviorGraphAgent behaviorGraphAgent;
    public Transform[] WayPoint;
    private NavMeshAgent agent;

    private int targetIndex = 0;
    private int direction = 1; // 1: 정방향, -1: 역방향

    [SerializeField] private bool isLooping = true; // true: 순환, false: 왕복

    void Start()
    {
        behaviorGraphAgent = GetComponent<BehaviorGraphAgent>();
        agent = GetComponent<NavMeshAgent>();
        agent.SetDestination(WayPoint[0].position);
    }

    void Update()
    {
    }

    public void SetPatrol()
    {
        if (agent.pathStatus == NavMeshPathStatus.PathComplete &&
            agent.remainingDistance - agent.stoppingDistance < 0.1f)
        {
            if(isLooping)
            {
                targetIndex = (targetIndex + 1) % WayPoint.Length;
            }
            else
            {
                if (targetIndex == 0)
                {
                    direction = 1;
                }
                else if (targetIndex == WayPoint.Length - 1)
                {
                    direction = -1;
                }

                targetIndex += direction;
                targetIndex = Mathf.Clamp(targetIndex, 0, WayPoint.Length - 1);
            }

            agent.SetDestination(WayPoint[targetIndex].position);
        }
    }
}

```

그리고 Action노드에서 일단 실행시키는 코드이다.  
```c#
using System;
using Unity.Behavior;
using UnityEngine;
using Action = Unity.Behavior.Action;
using Unity.Properties;
using UnityEngine.AI;
using UnityEngine.InputSystem.XR;

[Serializable, GeneratePropertyBag]
[NodeDescription(name: "AIPatrol", story: "[Self] 이동할캐릭터", category: "Action", id: "cc1ab74039e6a0db09484e91cfe64b34")]
public partial class AiPatrolAction : Action
{
    [SerializeReference] 
    public BlackboardVariable<GameObject> Self;

    private NavMeshAgent Agent;
    private AIController Controller;

    protected override Status OnStart()
    {
        GameObject AI = Self.Value;

        if (AI == null) return Status.Failure;

        Controller = AI.GetComponent<AIController>();
        if (Controller == null) return Status.Failure;

        return Status.Running;
    }

    protected override Status OnUpdate()
    {
        Controller.SetPatrol();

        return Status.Running;
    }

    protected override void OnEnd()
    {
    }
}
```

사실 이 방법이 맞는지는 모르겠다. 그리고 AI애니매이션이 나오지않는다. 그런데 캐릭터무브먼트부분에서 AI와 Player를 구분해야하나?
지금 여러 구조로 인한 머리가 아프다. 천천히 시간을 쓰면서 생각해봐야겠다. 언리얼을 할 때는 이런부분들이 이미 구현되어 있거나 명확히 나뉘어져 있어 편했는데 처음부터 내가 짜려고 하니 정말 어려운 부분들이 많은 거 같다. 