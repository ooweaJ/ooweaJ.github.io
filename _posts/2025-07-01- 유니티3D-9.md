---
title: 유니티3D - 9
date: 2025-07-01 15:00:00 +09:00
categories: [유니티,3D]
tags:
  [
    유니티, 3D
  ]
---

## 이번 목표
죽었을 때 AI가 총을 드랍하고 UI를 만들어 플레이어와 상호작용하여 픽업이 가능하게해보자.  

## 총기 드랍
일단 WeaponComponent에서 총기드랍을 만들생각을해보자.  
그리고 새로운 클래스로 DropItem 스크립트를 만들어서 관리해보자.  
현재 무기에서 DropData가 필요하다고 느껴졌다. Drop되는 아이템의 프리펩이 필요로 하기 떄문에 이 데이터를 GunWeapon에다가 넣어서 가져오겠다.  

```c#
    public void DropWeapon()
    {
        if (CurrentWeapon == null) return;

        DropData dropData = CurrentWeapon.Dropdata; // 현재 무기에서 드랍 데이터 추출

        GameObject dropObj = Instantiate(dropData.DropPrefab, transform.position, Quaternion.identity);
        DropItem dropItem = dropObj.GetComponent<DropItem>();
        dropItem.Init(dropData);

        Destroy(CurrentWeapon.gameObject);
        CurrentWeapon = null;
    }
```
이런식으로 현재무기에서 DropData를 가져와서 생성해주고 Init함수에서 캐싱한 후 현재무기를 지워주도록하자.  
DropData에 프리펩만 잘 들어있다면 씬에 잘 Drop될 것이다.  
이어서 DropItem 스크립트를 작성해보자.  
일단 콜리더를 이용해 플레이어가 들어오면 Ui를 띄어주기로 하자 그러기 위해선 또 새로운 ItemUIManager 스크립트를 작성하자.  
어디서든 UI매니저에 접근할 수 있게 싱글톤처럼 사용하겠다.  

```c#
using TMPro;
using UnityEngine;

public class ItemUIManager : MonoBehaviour
{
    public static ItemUIManager Instance;

    [SerializeField] private GameObject promptUI;
    [SerializeField] private TextMeshProUGUI itemNameText;

    void Awake()
    {
            if (Instance != null && Instance != this)
    {
        Destroy(gameObject);
        return;
    }

    Instance = this;
        promptUI.SetActive(false);
    }

    public void ShowPrompt(string itemName)
    {
        itemNameText.text = itemName;

        promptUI.SetActive(true);
    }

    public void HidePrompt()
    {
        promptUI.SetActive(false);
    }
}

```

이렇게 ItemUIManager를 구현한 후 DropItem 클래스에서 콜리더에 트리거를 이용해 UIManager를 가져와 UI를 On/Off 해주자.  
```c#
using UnityEngine;

public class DropItem : MonoBehaviour
{
    [SerializeField] BoxCollider BoxCollider;
    public DropData dropData;
    public float rotationSpeed = 100f;

    public void Init(DropData data)
    {
        dropData = data;
    }

    private void Update()
    {
        transform.Rotate(Vector3.up * rotationSpeed * Time.deltaTime);
    }

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            // UI 표시
            ItemUIManager.Instance.ShowPrompt(dropData.Name);
        }
    }

    private void OnTriggerExit(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            // UI 숨기기
            ItemUIManager.Instance.HidePrompt();
        }
    }
}

```

{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/UI레이캐스트.mp4" title="UI레이캐스트" %}

의도한대로 잘된다. 유니티는 한글폰트가 지원이 안되서 폰트를 따로 가져와서 등록을하고 만들어줘야한다.  
주의할점으로 필자도 처음에 가져온폰트가 그대로 네모모양으로 깨져서 한글이 지원이 안되는 폰트인가 했는데 Size조절을 해줘야한다.   너무 커서 네모로 깨졌던 것...  
이제  잘 드롭되니 픽업을 해보도록하자.

## 픽업
트리거에서 이제 플레이어에게 아이템 정보를 넘기고 F키를 눌러 픽업하는 코드를 구성해보자.  

```c#
using UnityEngine;

public class DropItem : MonoBehaviour
{
    [SerializeField] BoxCollider BoxCollider;
    public DropData dropData;
    public float rotationSpeed = 100f;

    public void Init(DropData data)
    {
        dropData = data;
    }

    private void Update()
    {
        transform.Rotate(Vector3.up * rotationSpeed * Time.deltaTime);
    }

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            // UI 표시
            ItemUIManager.Instance.ShowPrompt(dropData.Name);
            PlayerController PC = other.GetComponent<PlayerController>();
            PC.SetPickUp(true, this);
        }
    }

    private void OnTriggerExit(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            // UI 숨기기
            ItemUIManager.Instance.HidePrompt();
            PlayerController PC = other.GetComponent<PlayerController>();
            PC.SetPickUp(false, null);
        }
    }
}

```

이제 PC에서 WeaponComponent와 상호작용을 구성해보자.  

```c#
    public void OnPickUp(InputAction.CallbackContext context)
    {
        if (context.performed)
        {
            if (PickUp == true && dropItem != null)
            {
                weapon.PickUpItem(dropItem);
                Destroy(dropItem);
                dropItem = null;
            }
        }
    }

public class WeaponComponent : MonoBehaviour
{
        public void PickUpItem(DropItem gunWeapon)
    {
        if (CurrentWeapon == null)
        {
            CurrentWeapon = Instantiate(gunWeapon.dropData.GunWeapon, Hand_R);
            CurrentWeapon.SetOwner(gameObject);
        }
        else
        {
            DropWeapon();
            CurrentWeapon = Instantiate(gunWeapon.dropData.GunWeapon, Hand_R);
            CurrentWeapon.SetOwner(gameObject);
        }
    }
}
```

{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/픽업문제영상.mp4" title="픽업문제영상" %}

여기서 문제가 생겼는데 드롭된 아이템이 삭제가되면서 Player에게 무기 장착이되어야하는데 장착이 되지않는다. 
UI는 콜리전이 박스라 끝부분에서 나갔다 들어왔다하는거 같다.  

디버깅을 해봤는데 일단 DropData가 다른건 잘 전달되는데 Gunweapon 변수만 null로 된다.  
여기서 나는 이 데이터에 자기자신의 프리펩을 넣어야했었는데 이 부분에서 먼가 이상하다고 느껴 찾아봤다.  
순환 참조 + 직렬화 꼬임의 원인이라고 나온다.  

이제 내코드에서 문제점을 고쳐야한다. 

```c#

[System.Serializable]
public struct DropData
{
    public GameObject DropPrefab;
    public GunWeapon GunWeapon;
    public string Name;
}

public abstract class GunWeapon : MonoBehaviour
{
    public GunData data;
    public DropData Dropdata;
}
```

위에 코드처럼 자기자신의 클래스에서 만든 구조체에 자신클래스가 들어가는게 문제이다.  
언리얼에서는 c++로 아마 *변수로 처리했는데 이게 안되는거 같다. 
그래서 해결법으로는 ScriptableObject 상속하여 DropData 클래스를 만들어서 관리를 해야한다고 한다.  
ScriptableObject를 한 번 사용해봤는데 이게 아마 언리얼의 데이터에셋이랑 비슷하다고 한다.  
문제를 해결하고 이제 픽업을 했을때나 Ai가 죽었을때 무기를 드롭하는데 이 때 총을 날려주자 Rigidbody를 이용하겠다.  

```c#
    public void OnDrop(Vector3 Direction)
    {
        float force = 1f;
        Rigidbody.AddForce(Direction * force, ForceMode.Impulse);
    }

```
각자의 컨트롤러에서 방향을 받아 적당한 힘으로 날려주었다.  
그리고 이제 픽업 UI가 뜨는 것을 플레이어의 에임 즉 카메라 가운데에 맞으면 UI를 띄우게끔 만들어준다.  

- dropItem 코드
```c#

    public void OnUIItem()
    {
        ItemUIManager.Instance.ShowPrompt(dropData.Name);
    }

    public void OffUIItem()
    {
        ItemUIManager.Instance.HidePrompt();
    }

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            PlayerController PC = other.GetComponent<PlayerController>();
            PC.SetPickUp(true, this);
        }
    }

    private void OnTriggerExit(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            PlayerController PC = other.GetComponent<PlayerController>();
            PC.SetPickUp(false, null);
            OffUIItem();
        }
    }
```
- Player 코드
```c#
   void Update()
   {
       if (PickUp)
       {
           OnUIRaycast();
       }
   }

   private void OnUIRaycast()
   {
       Camera cam = Camera.main;
       Vector3 origin = cam.transform.position;
       Vector3 direction = cam.transform.forward;

       if (Physics.Raycast(origin, direction, out RaycastHit hit, rayDistance, dropItemLayer))
       {
           DropItem dropItem = hit.collider.GetComponent<DropItem>();
           dropItem.OnUIItem();
           currentTarget = dropItem;
       }
       else
       {
           if (currentTarget != null)
           {
               currentTarget.OffUIItem();
           }
       }
   }

       public void OnPickUp(InputAction.CallbackContext context)
    {
        if (context.performed)
        {
            if (PickUp == true && dropItem != null)
            {
                weapon.PickUpItem(dropItem);
                Destroy(dropItem.gameObject);
                currentTarget.OffUIItem();
                currentTarget = null;
                dropItem = null;
            }
        }
    }
```
간단하게 코드를 보면 DropItem에서 UI를 ON/OFF 하는 함수를 간단하게 작성하여 작동하고 
Player에서는 카메라의 정면방향으로 Raycast를 진행시켜 LayerMask를 통해 DropItem 레이어만 검출하게끔하고 검출되면 UI를키고 currentTarget변수에 캐싱하여 저장하고있다가.  
픽업을하거나 Player의 에임이 벗어나면 UI를 꺼주었다.  

{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/무기픽업 완성.mp4" title="무기픽업 완성" %}

- 이 작업을 하면서 얻은점
일단 레이어 부분에서 나는 처음에 이 Box나 Sphere 콜리더에서 사진처럼 레이어 포함이라는 기능을 오해하고있었다.  
<img width="335" height="233" alt="콜리더사진" src="https://ooweaJ.github.io/assets/img/3D/콜리더사진.png" />
레이어 포함 부분에 내가 DropItem을 하면 이 BoxCollider는 DropItem레이어인 상태인줄알고 진행했다.  
<img width="340" height="76" alt="실제레이어" src="https://ooweaJ.github.io/assets/img/3D/실제레이어.png" />
실제로는 이 게임 오브젝트 레이어 설정으로 진행되는 것.  
이 아이템 범위 즉 플레이어가 픽업범위에 들어오는 용도로 사용하는 Sphere콜리더에 자꾸 RayCast가 충돌하여 에임에 아이템이 안들어와도 UI가 켜졌다.  
여기서 이제 DropItem레이어가 아닌데 왜 이게 충돌이 되지? 하는 의문점이 생겨서 개념이 확실히 정리가 될수있었다.  
즉 Collider에 레이어 포함은 현재 게임 오브젝트가 충돌되지않는 레이어와 충돌이 가능하게끔 해주는 역할이였다.  
<img width="287" height="885" alt="PlayerOnly" src="https://ooweaJ.github.io/assets/img/3D/PlayerOnly.png" />
나는 그래서  그림처럼 DropAKM프리펩에 빈오브젝트를 하나 더 추가하여 PlayerOnly레이어를 만들어 이 오브젝트 레이어에 할당해주었다.  

즉 정리를 하자면 언리얼처럼 콜리더마다 레이어를 설정할 수 없어 유니티는 계층구조로 오브젝트를 만들고 오브젝트마다 알맞는 레이어를 설정해줘야한다.  
그리고 레이어 포함 기능은 현재 레이어가 충돌하지 않는 다른 레이어를 충돌이 가능하게 끔 해주는 기능이다.  

{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/레이어 예시영상.mp4" title="레이어 예시영상" %}
영상과 같이 Player와 충돌이 적용되어 올라갔다가 다시 바꾸면 적용되지않아 내려가는 모습을 볼 수 있다.  

그리고 Ui 방식을 월드와 스크린중에 고민을 해봤는데 영상처럼 나는 스크린이 맞다고 판단했다.   
{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/UI방식영상.mp4" title="UI방식영상" %}