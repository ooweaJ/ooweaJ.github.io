---
title: 유니티3D - 8
date: 2025-06-20 15:00:00 +09:00
categories: [유니티,3D]
tags:
  [
    유니티, 3D
  ]
---
## 이번 목표
플레이어와 AI에 체력을 만들어 보자

### 체력  
체력을 구현하기위해 AI와 Player가 사용할 Status 클래스를 만들어 관리해주자.  

```c#
using UnityEngine;

public class Status : MonoBehaviour
{
    [SerializeField] private float maxHP = 100f;
    [SerializeField] private float currentHP;

    void Start()
    {
        currentHP = maxHP;
    }

    public void IncreaseHP(float amount)
    {
        currentHP = Mathf.Clamp(currentHP + amount, 0, maxHP);
    }

    public void DecreaseHP(float amount)
    {
        currentHP = Mathf.Clamp(currentHP - amount, 0, maxHP);
    }

    public float GetCurrentHP() => currentHP;
    public float GetMaxHP() => maxHP;
    public float GetHPPercent() => currentHP / maxHP;
}

```

HP 구현을 마친모습이고 이제 TakeDamage를 만들어보자.  

### 데미지
데미지를 구현하려면 일단 몸통과 헤드샷으로 분리되는 콜리더를 캐릭터에 배치해주도록 해야겠다.  
여기서 Tag를 만들어 Head인 경우만 처리하고 나머지는 통일하게 하도록 하겠다.  
헤드샷은 데미지를 3배 더  높여서 주고 Status에도 Dead 판정을 만들어놨다.
```c#

        if (Physics.Raycast(origin, direction, out RaycastHit hit, MaxDistance))
        {
            Status status = hit.collider.GetComponentInParent<Status>();
            if (status != null)
            {
                if (hit.collider.CompareTag("Head"))
                {
                    status.DecreaseHP(data.damage * 3);
                }
                else
                {
                    status.DecreaseHP(data.damage);
                }
            }
```
State의 OnDead를 호출하여 애니메이션에도 영향이 가게하자.
```c#
    public void DecreaseHP(float amount)
    {
        currentHP = Mathf.Clamp(currentHP - amount, 0, maxHP);

        if(currentHP <= 0)
        {
           State.OnDead();
        }
    }
```

State에서 델리게이트로 애니메이션에 보내주어 새로운 상황을 추가해도 역시 편하다.
```c#
    public void SetCharacterState(int InState)
    {
        if (characterState == (ECharacterState)InState)
        {
            characterState = ECharacterState.Idle;
        }
        else
        {
            characterState = (ECharacterState)InState;
        }

        characterStateChange.Invoke(characterState);
    }

    public void OnDead()
    {
        SetCharacterState((int)ECharacterState.Dead);
    }
```

애니메이션 컨트롤러 부분에서 어떻게 적용되고 있는지 확인 후 죽는 애니메이션을 만들어보자.
```C#

    void SetAnimState(ECharacterState state)
    {
        animator.SetInteger("State", (int)state);
    }

```
그에 맞게 애님컨트롤러에서 Any State에서 조건에 맞게 실행시켜보았다.

<img width="1617" height="649" alt="DEAD상태BT우선순위로해결" src="https://ooweaJ.github.io/assets/img/3D/Dead애님.png" />

{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/Dead.mp4" title="Dead" %}
실행한 결과 애니메이션이 계속 재생된다. 생각을 해보니 이런거는 트리거로 설정을 해야할거 같다.  
내가만든 델리게이트는 계속 유지되는 상태를 위에 만들어놓은 코드인 거 같다.  
나중에 피스톨 상태를 추가할 때 용이한 방식이다.  
트리거로 다시 코드를 만들어 재생해보자. 
State 클래스에 트리거용 델리게이트 변수를 만들어 애님컨트롤러에 바인딩해 사용하자.
```c#
public class State : MonoBehaviour
{
    public event Action OnCharacterDead;

    public void OnDead()
    {
        OnCharacterDead.Invoke();
    }
}

public class AnimController : MonoBehaviour
{
      void OnEnable()
    {
        state.OnCharacterDead += OnDead;
    }
        void OnDisable()
    {
        state.OnCharacterDead -= OnDead;
    }

    void OnDead()
    {
        animator.SetTrigger("Dead");
    }
}
```

{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/DeadFix.mp4" title="DeadFix" %}

잘 한번만 실행된다. 하지만 문제점이 보인다 이제 죽었을 때 BT에서 처리와 HP가 0 이하일 때 공격을 받으면 트리거가 한 번 더 실행되는 상황인거같기때문에 예외처리해주자.  
일단 Status에서 Dead처리를 하기 떄문에 Player와 AI 둘 다 다르게 구현되기 떄문에 각자 컴포터는트에서 실행되어야한다.  
컨트롤러의 부모클래스를 만들까 인터페이스로 만들까 생각하다 인터페이스로 그냥 추가했다.  

```c#
public class Status : MonoBehaviour
{
    private IController controller;

    void Start()
    {
        controller = GetComponent<IController>();
    }

    public void DecreaseHP(float amount)
    {
        if (currentHP == 0) return;
        currentHP = Mathf.Clamp(currentHP - amount, 0, maxHP);

        if(currentHP <= 0)
        {
            OnDead();
        }
    }

    private void OnDead()
    {
        State.OnDead();
        controller.OnDead();
    }
}
```
이제 AI컨트롤러에서 OnDead를 구현해보자 BTState를 Dead로 바꿔주고 StopChase() 함수로 이동을 멈춰주자
```c#
    public void OnDead()
    {
        StopChase();
        SetBehaviorState(BehaviorState.Dead);
    }
```
이렇게 하고보니 이러면 DeadAction에서는 어떤걸 정의해야할까 고민좀 해봐야겠다. 
필요가 없는거 같기도 한데 일단 추가할 부분이 생길수도 있으니 냅둬보자.  

{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/DeadFix2.mp4" title="DeadFix2" %}

문제가 생겼다. AI가 총을 쏘고있는 상태에서 Dead상태가 되면 총을 계속 쏜다.  

{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/죽어도쏘는문제.mp4" title="죽어도쏘는문제" %}

쉽게 State에서 Idle상태가 아니면 안되게 예외처리 해주면 된다.  
안전하게 IsCanFire와 StartFire 부분에 예외처리를 둘 다 하자.  

```c#
    public bool IsCanFire()
    {
        if(State.GetState() != ECharacterState.Idle) return false;
    }
        public void StartFire()
    {
        if (State.GetState() != ECharacterState.Idle) return;
    }
```

{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/고친후문제영상.mp4" title="고친후문제영상" %}

예외처리를 해도 이제 이동을 한다 아마 추격액션이 작동이 되는거 같다.  
이 부분을 DeadAction에서 탈출을 못하게 하면 될듯하다.

{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/Chase문제.mp4" title="Chase문제" %}

근데 이 상황을 관찰하면서 문제가 하나 더 발생했다. 총을 쏠 때 움직이면 Chase 부분 액션이 실행 될 때가 있다.  
이것도 고쳐야 자연스럽게 될 것이다 원인을 찾아보자.  

<img width="1617" height="649" alt="DEAD상태BT우선순위로해결" src="https://ooweaJ.github.io/assets/img/3D/DEAD상태BT우선순위로해결.png" />

Dead상태일때도 따라오는것을 막기위해 나는 BT Action순서를 Dead를 제일 좌측으로 옮겨 해결했다.  

일단 첫번째로 의심되는건 BT의 Try In Order다 내가 제대로 이해하지 못하고 사용하고 있을 가능성이 높다.  
두번째로는 내 코드의 문제점을 찾아보는 것. FireAction 코드를 살펴보자.  

```c#
using System;
using Unity.Behavior;
using UnityEngine;
using Action = Unity.Behavior.Action;
using Unity.Properties;

[Serializable, GeneratePropertyBag]
[NodeDescription(name: "Fire", story: "[Self] Firing", category: "Action", id: "e5228f79ee4bb5328d1ffceb33134cdf")]
public partial class FireAction : Action
{
    [SerializeReference] public BlackboardVariable<GameObject> Self;
    private AIController Controller;

    protected override Status OnStart()
    {
        GameObject AI = Self.Value;

        if (AI == null) return Status.Failure;

        Controller = AI.GetComponent<AIController>();
        if (Controller == null) return Status.Failure;

        Controller.StartFire();
        return Status.Running;
    }

    protected override Status OnUpdate()
    {
        Controller.RotateToTarget();

        if(Controller.IsDead())
            return Status.Failure;

        if (Controller.IsCanFire())
            return Status.Running;

        Controller.SetBehaviorState(BehaviorState.Chase);
        return Status.Success;
    }

    protected override void OnEnd()
    {
        Controller.OffFire();
    }
}
```
코드를 봤을 때 IsCanFire()가 false가 될때를 생각해서 디버그를 생각했다.  
IsCanFire() 함수내에 false가 return 되는 경우에서 Raycast가 Player로 인지 안됐을 때 디버그를 걸었다.  

```c#
    public bool IsCanFire()
    {
        if(State.GetState() != ECharacterState.Idle) return false;

        float TargetDistance = Vector3.Distance(transform.position, Target.transform.position);
        if (AttackRange < TargetDistance) return false;

        Vector3 dirToTarget = (Target.transform.position - transform.position).normalized;
        float distToTarget = Vector3.Distance(transform.position, Target.transform.position);
        if (Physics.Raycast(transform.position + Vector3.up, dirToTarget, out RaycastHit hit, distToTarget))
        {
            if (hit.transform.CompareTag("Player"))
            {
                return true;
            }
        }
        return false; // 여 줄에 디버그를 걸고 걸렸을 때 hit 정보를 보자
    }
```
<img width="986" height="714" alt="디버그" src="https://ooweaJ.github.io/assets/img/3D/디버그.png" />

히트 정보를 보니 총알이 트레이스에 걸렸던 것 여기서 코드를 어떻게 수정해야 이 오류가 안날지 생각해보았다.  
Bullet 레이어를 만들어 RayCast 마스크를 사용해보겠다.  

{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/해결전.mp4" title="해결전" %}
{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/해결후.mp4" title="해결후" %}

해결이 잘된모습이다. 다음에는 Dead처리를 제대로 만들고 템이 필드에 드랍되고 총알도 생기게하겠다.