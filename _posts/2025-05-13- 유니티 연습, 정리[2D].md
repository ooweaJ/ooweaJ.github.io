---
title: 유니티 연습[2D]
date: 2025-05-13 15:00:00 +09:00
categories: [유니티]
tags:
  [
    유니티,
  ]
---
## 참고 링크
참고 [링크](https://learn.unity.com/tutorial/unreal-gaebaljareul-wihan-unity-sayong-gaideu#60ef8a11edbc2a002096ef26)

## 오브젝트 생성
두 엔진 게임 월드에 존재하는 기본 엔티티
언리얼 - 액터 , 유니티 - 게임 오브젝트

공통점 - 둘 다 컴포넌트가 적용되고 , 트랜스폼을 사용해 월드에서 이동, 회전 및 스케일 조정이 가능하다.
**차이점**
언리얼 액터 - Unreal에는 폰(Pawn)이나 캐릭터(Character)와 같이 특화된 액터가 있습니다. Unreal의 액터는 코드를 통해 확장과 특화를 거쳐 액터 자체에 특별한 기능을 추가할 수 있습니다.
유니티 게임 오브젝트 - 반면 Unity의 게임 오브젝트는 봉인된 클래스이며 확장과 특화가 불가능합니다. 게임 오브젝트의 동작은 전적으로 자체 컴포넌트를 바탕으로 정의됩니다. 플레이어 캐릭터 폰 대신, 플레이어 캐릭터 컴포넌트가 포함된 게임 오브젝트를 사용합니다.

**이벤트 함수**
Begin Play() = Start()
Tick() = Update()
OnActorOverlapBegin() = OnTriggerEnter()
Destroyed() = OnDestroy()

**Unity의 컴포넌트**
Unity 컴포넌트는 액터 컴포넌트처럼 작동하고 일반적으로 Unity에서 트랜스폼을 가지는 유일한 엔티티는 게임 오브젝트입니다.  
계층 창에서 한 게임 오브젝트를 다른 게임 오브젝트로 드래그하여 계층 구조를 만들면 씬 컴포넌트와 같은 기능을 사용할 수 있습니다.

두 엔진에서 집을 만드는 상황
Unreal - 바닥, 벽, 지붕 등의 정적 메시 컴포넌트가 포함된 '집' 액터를 만들 것입니다. 

Unity에서는 '집'이라는 부모 게임 오브젝트를 만들 것입니다. 이때 바닥, 벽, 지붕에 대한 별도의 자식 게임 오브젝트를 추가하며, 게임 오브젝트마다 고유의 Mesh Renderer 컴포넌트를 적용합니다.

**Unity에서 컴포넌트 추가**
그림과 같이 쉽게 추가할 수 있다.

여기서 New Script 버튼을 선택하면 새 컴포넌트 스크립트를 즉시 생성하여 게임 오브젝트에 추가할 수도 있습니다. 이 부분에서 유니티는 컴포넌트를 Script로 만드는 걸로 유사 추정 중

런타임 시 컴포넌트를 추가할 수도 있습니다. AddComponent<T>() 함수를 사용.

그림과 같이 패널에 마우스 우클릭을 하면 오브젝트를 생성할 수 있다.

**블루프린트와 프리팹**
프리팹은 에셋으로 저장되는 게임 오브젝트의 계층 구조입니다. 프리팹은 프로젝트 창에서 씬 뷰로 직접 드래그 앤 드롭하거나 스크립트에서 레퍼런스를 통해 생성할 수 있습니다.
프리팹의 모든 동작은 포함된 게임 오브젝트의 컴포넌트에서 유래됩니다. 커스텀 동작은 C# 스크립트를 작성하여 생성해야한다. 블루프린트 처럼 시각적인 스크립트는 없다.

빈 오브젝트 생성 후 씬뷰에서 확인할 수 있게 아이콘을 바꾼후 오브젝트명을 Waypoint로 변경 후 프로젝트창에 드래그 하면 프리팹이 생성된다.

**2D타일맵에서 게임오브젝트 배치**
타일맵에서 타일팔레트를 열어 Default Brush-> GameObject Brush로 바꾼 후 Cells를 열어 게임 오브젝트부분에 Waypoint 프리팹을 넣은 후 브러시 아이콘을 클릭 후 타일맵에 배치할 수 있다.

**직렬화, 에디터 노출**
유니티의 [SerializeField]는 언리얼의 UPROPERTY(EditAnywhere)와 비슷한 기능이다.
[System.Serializable] 구조체, 클래스 직렬화 메모리 상에 존재하는 오브젝트 정보를 string 또는 Byte 데이터 형태로 변형하여 드라이브 저장, 네트워크를 통한 데이터 전송 가능하다. (직렬화를하면 Inspector View에서 클래스 내부의 변수 정보들을 수정 가능)

**컴파일**
유니티는 코드를 저장하면 자동으로 감지하여 컴파일을하고 반영을 해준다. 직접 빌드를 안해도 되는거 같다.
## 화면뷰
화면뷰에는 씬뷰랑 게임뷰가 있다.
주로 씬뷰는 게임을 만들어가는 과정이고
게임뷰는 진짜 게임을 플레이하는 화면이다.
언리얼과는 두 기능을 같은 뷰에서 한다는 차이점이 있는 것 같다.

UI를 처음 생성하면 Canvas 랑 EventSystem이 같이 생성된다.
interactable 버튼 활성화 / 비활성화 ?

Extra Settings 에서
레이캐스트 타겟(Raycast Target)변수는 true일 경우 UI를 눌러 상호작용이 가능한 변수이다.

Getter / Setter

```cpp
class Character
{
private:
    int attackDamage;

public:
    int GetDamage() const { return attackDamage; }
    void SetDamage(int value) { attackDamage = value; }
};
```

```c#
public class Character
{
    private int attackDamage;

    public int Damage => attackDamage; // 읽기 전용 (Getter만)
}

```
```c#
public int Damage
{
    get { return attackDamage; }
    set { attackDamage = value; }
}
```
```c#
public int Damage { get; set; }
public int Damage { get; private set; }
```

C#은 C++ 처럼 함수호출을 하여 관리하지 않고 읽기/쓰기 기능을 변수처럼 간단하게 할 수 있다.
```c#
character.Damage; // getter
character.Damage = 100; // setter
```

[CreateAssetMenu]
MonoBehaviour - > 씬에 붙이는 컴포넌트용 [CreateAssetMenu]사용 불가
ScriptableObject -> 프로젝트 내 데이터 에셋으로 관리하는 용도 [CreateAssetMenu]사용 가능

UI위에 마우스가 있을 때 검출하는 방법
```c#
if (EventSystem.current.IsPointerOverGameObject())
{
    return;
}
```
📌EventSystem.current란?
- Unity의 UI 이벤트 처리 시스템을 관리하는 전역 객체입니다.
- 씬(Scene)에 반드시 EventSystem 컴포넌트가 있어야 작동합니다.
- 하나의 씬에는 보통 EventSystem이 단 하나만 존재합니다. (자동 생성되거나 수동으로 추가)

❓ IsPointerOverGameObject()란?
- 현재 마우스 포인터(PC 기준)가 UI 요소 위에 있는지를 판단합니다.
- GraphicRaycaster를 사용해 UI 컴포넌트가 마우스 포인터 위치에 존재하는지 판별합니다.

모바일 예시 코드
```c#
if (EventSystem.current.IsPointerOverGameObject(Input.GetTouch(0).fingerId))
{
    return;
}
```

패널 UI에 grid layout group 컴포넌트룰 추가하여 언리얼의 grid 패널과 비슷한 자식으로 배치되는 UI들을 격자 형태로 정렬 가능하는거 같다.
content Size Fitter 컴포넌트를 추가하면 컴포넌트를 가지고 있는 패널 오브젝트의 크기 설정이 가능하다.
content Size Fitter 의 옵션에서 Preferred Size로 바꾸면 자식 오브젝트들의 크기에 따라 패널 오브젝트의 크기가 설정된다.

[Header("Commons")]
인스펙터 뷰에 표시되는 변수들을 용도별로 구분하기 위해 사용하는 어티르뷰트 string에 작성된 내용을 굵을 글씨로 표시

부모 컴포넌트 가져오는 법 언리얼과의 차이
유니티
```c#
GetComponentInParent<TowerWeapon>()
```
자식 GameObject에서 부모 GameObject를 따라 올라감 올라가면서 각 GameObject에서 GetComponent<T>()를 시도하여 가져온다.

언리얼
```cpp
AActor* OwnerActor = GetOwner();
if (OwnerActor)
{
    UTowerWeaponComponent* TowerWeapon = OwnerActor->FindComponentByClass<UTowerWeaponComponent>();
    if (TowerWeapon)
    {
        // TowerWeapon 사용 가능
    }
}
```
언리얼은 컴포넌트를 소유하고 있는 Actor를 가져와서 컴포넌트를 찾아오는 GetComponentByClass()를 사용하여 가져온다.

this.gameObject.transform.parent 이방식으로 부모를 가져올 수 있다?

계속 쓰다보니 액터와 게임오브젝트의 차이가 명확해진다.

GameObject는 그 자체로 아무 동작도 하지 않고 진짜 로직은 Component들에 의해 구현된다.
모든 동작은 MonoBehaviour를 상속한 컴포넌트(Script)에서 처리된다.
GameObject = 껍데기 (Transform, 네이밍, 계층)
Component = 진짜 기능 (동작, 반응, 물리 등)

언리얼의 Actor는 단순 껍데기가 아니라 기능을 가질 수 있는 클래스인 점에서 차이가 있고 Unreal의 구조는 조금 더 클래스 지향적이고, 상속과 오버라이딩을 더 많이 활용하는 차이가 있는 것 같다.

✅ 구조 비교 요약
항목	            Unity (GameObject)	                       Unreal (Actor)
기본 단위	      GameObject	                        Actor
동작 위치	      대부분 Component (MonoBehaviour)	     Actor 자체 + Component
계층 구조	      Transform 기반	                    SceneComponent 기반 (Root 포함)
스크립트 구조	   Script는 컴포넌트 형태로 붙임	       클래스 상속 중심 구조 (AActor → AMyActor)
생명주기 함수	   Start, Update, OnTriggerEnter 등	    BeginPlay, Tick, NotifyHit 등

✅ 한 줄 정리
Unity는 “GameObject + Component 조합형 구조”,
Unreal은 **“Actor 중심 + Component 보완형 구조”**

**유형 간 캐스팅**
Unreal에서 타입캐스팅은 대부분 생성된 Blueprint 캐스팅 노드 또는 C++의 Cast<Type>()함수를 통해 수행됩니다.
Unity에서는 "as" 키워드로 캐스트하거나 c 스타일 캐스팅을 사용합니다. 두 경우 모두 캐스트가 실패할 경우 결과는 null입니다.
CastedType asCast = obj as CastedType;
CastedType cStyleCast = (CastedType)obj;

**비동기 코드(지연/타임라인)**
Unreal에서는 딜레이 및 타임라인 노드를 사용하여 간편하게 이벤트 타이밍을 제어하고 시간에 따라 프로퍼티를 수정할 수 있습니다.
Unity에서는 이러한 지연 실행을 코루틴(Coroutine)으로 처리할 수 ​​있습니다. 코루틴은 일반적인 코드 실행과는 독립적으로 실행되는 특수 함수로, "yield" 명령을 사용하여 원하는 대로 지연하거나 중지할 수 있습니다. 모든 코루틴 함수는 IEnumerator를 반환해야 하며, 이를 통해 yield를 사용하여 중지 또는 지연을 반환할 수 있습니다. 

**Awake함수**
Awake함수는 언리얼에서 OnConstruction()랑 비슷하다. Beginplay(Start) 함수보다 먼저 실행된다.
정확한 호출 시점은 오브젝트가 씬에 생성되었을 때이다.
Awake()는 다른 컴포넌트의 참조를 가져올 때 주로 사용하고 Start()는 초기화 이후 게임 시작 직전 로직을 처리하는게 좋다.
그리고 오브젝트가 비활성화 상태로 시작되면 Start()는 호출되지 않지만 Awake()는 호출된다.