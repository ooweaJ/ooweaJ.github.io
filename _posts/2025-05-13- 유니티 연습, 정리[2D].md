# 🎮 Unity 2D 타워 디펜스 게임 - 학습 정리

## 📚 참고 자료
- [Unity 사용 가이드](https://learn.unity.com/tutorial/unreal-gaebaljareul-wihan-unity-sayong-gaideu#60ef8a11edbc2a002096ef26)

---

## 🔍 Unity vs Unreal 엔진 비교

### **기본 엔티티**

| 구분 | Unity | Unreal |
|:-----|:------|:------|
| **기본 단위** | GameObject | Actor |
| **동작 위치** | Component (MonoBehaviour) | Actor 자체 + Component |
| **계층 구조** | Transform 기반 | SceneComponent 기반 |
| **스크립트 구조** | Script는 컴포넌트 형태로 붙임 | 클래스 상속 중심 구조 |

### **이벤트 함수 비교**

| Unity | Unreal | 설명 |
|:------|:------|:------|
| `Start()` | `BeginPlay()` | 게임 시작 시 호출 |
| `Update()` | `Tick()` | 매 프레임 호출 |
| `OnTriggerEnter()` | `OnActorOverlapBegin()` | 충돌 시작 시 호출 |
| `OnDestroy()` | `Destroyed()` | 오브젝트 파괴 시 호출 |

### **구조적 차이점**
- **Unity**: GameObject는 껍데기, 모든 동작은 Component에서 처리
- **Unreal**: Actor는 기능을 가질 수 있는 클래스, 상속과 오버라이딩 중심

---

## 🛠 Unity 핵심 개념

### **컴포넌트 시스템**
- **Transform**: 위치, 회전, 크기 조작, 부모-자식 관계
- **MonoBehaviour**: 스크립트의 기본 클래스
- **AddComponent<T>()**: 런타임 시 컴포넌트 추가

### **프리팹 (Prefab)**
- 에셋으로 저장되는 게임 오브젝트의 계층 구조
- 프로젝트 창에서 씬 뷰로 드래그 앤 드롭
- 스크립트에서 레퍼런스를 통해 생성 가능

### **타일맵 시스템**
- **GameObject Brush**: 타일맵에 게임 오브젝트 배치
- **Default Brush → GameObject Brush**: 타일 대신 오브젝트 배치

---

## 💻 C# 프로그래밍 기법

### **직렬화 (Serialization)**
```csharp
[SerializeField] private int health;           // Inspector 노출
[System.Serializable] public struct WaveData;   // 구조체 직렬화
```

### **프로퍼티 (Property)**
```csharp
// 읽기 전용
public int Damage => attackDamage;

// 읽기/쓰기
public int Health { get; set; }

// 읽기/쓰기 (외부 읽기, 내부 쓰기)
public int Level { get; private set; }
```

### **ScriptableObject**
```csharp
[CreateAssetMenu(fileName = "TowerData", menuName = "Game/Tower Data")]
public class TowerTemplate : ScriptableObject
{
    // 데이터 정의
}
```

### **코루틴 (Coroutine)**
```csharp
private IEnumerator SpawnEnemy()
{
    while (true)
    {
        // 적 생성 로직
        yield return new WaitForSeconds(spawnTime);
    }
}
```

---

## 🎮 UI 시스템

### **기본 UI 구조**
- **Canvas**: UI 요소의 컨테이너
- **EventSystem**: UI 이벤트 처리 시스템
- **GraphicRaycaster**: UI 상호작용 감지

### **UI 상호작용 감지**
```csharp
// PC 마우스
if (EventSystem.current.IsPointerOverGameObject())
{
    return; // UI 위에 마우스가 있음
}

// 모바일 터치
if (EventSystem.current.IsPointerOverGameObject(Input.GetTouch(0).fingerId))
{
    return; // UI 위에 터치가 있음
}
```

### **UI 레이아웃 컴포넌트**
- **Grid Layout Group**: 격자 형태로 자식 UI 정렬
- **Content Size Fitter**: 자식 크기에 따른 패널 크기 자동 조정

---

## 🔧 Unity 생명주기

### **초기화 순서**
1. **Awake()**: 오브젝트 생성 시 호출 (다른 컴포넌트 참조 가져올 때)
2. **Start()**: 게임 시작 직전 호출 (초기화 이후 로직)

### **주요 특징**
- **Awake()**: 비활성화 상태에서도 호출됨
- **Start()**: 비활성화 상태에서는 호출되지 않음
- **자동 컴파일**: 코드 저장 시 자동 감지 및 컴파일

---

## 🎯 타워 디펜스 게임 - 기술 스택

### **🎯 개발 환경**

| 구분 | 내용 |
|:-----|:-----|
| **게임 엔진** | Unity 2022.3 LTS, Visual Studio 2022 Community |
| **플랫폼** | PC (Windows), 2D 게임 |
| **언어** | C# Script |

### **💻 프로그래밍 패턴**

| 구분 | 내용 |
|:-----|:-----|
| **객체 지향 설계** | 클래스 기반 컴포넌트 구조, 상속 및 다형성 활용 |
| **상태 머신 패턴** | `WeaponState` enum을 이용한 무기 상태 관리 |
| **코루틴 시스템** | `IEnumerator`를 활용한 비동기 게임 로직 |
| **이벤트 기반 로직** | 오브젝트 간 통신 및 상호작용 시스템 |
| **매니저 클래스 구조** | `EnemySpawner`, `TowerSpawner`, `WaveSystem` 등 |

### **🛠 Unity 핵심 기능 활용**

| 구분 | 내용 |
|:-----|:-----|
| **Transform 시스템** | 위치, 회전, 크기 조작, 부모-자식 관계 관리 |
| **SpriteRenderer** | 2D 스프라이트 렌더링, 동적 스프라이트 변경 |
| **Physics 2D** | `OnTriggerEnter2D`, `Physics2D.RaycastAll()` |
| **Collider2D** | 충돌 감지 및 물리 상호작용 |
| **LayerMask** | 특정 오브젝트와만 상호작용하는 충돌 시스템 |
| **UI 시스템** | Canvas, Button, TextMeshPro, Slider |

### **⚙ 게임 로직 시스템**

| 구분 | 내용 |
|:-----|:-----|
| **웨이브 시스템** | `Wave` 구조체 기반 단계별 적 스폰 |
| **적 스폰 시스템** | `EnemySpawner` - 코루틴을 이용한 시간차 생성 |
| **타워 AI 시스템** | `TowerWeapon` - 타겟 추적, 발사, 회전, 업그레이드 |
| **적 AI 시스템** | `Enemy` - 웨이포인트 기반 경로 이동 |
| **투사체 시스템** | `ProJectile` - 물리 기반 충돌 감지 및 데미지 처리 |
| **경제 시스템** | `PlayerGold`, `PlayerHP` - 골드 관리, 체력 시스템 |

### **🎨 시각 효과 및 애니메이션**

| 구분 | 내용 |
|:-----|:-----|
| **LineRenderer** | 레이저 무기의 실시간 시각적 표현 |
| **TextMeshPro** | `TMPAlpha.cs` - 텍스트 페이드 효과 |
| **동적 스프라이트 변경** | 타워 레벨업 시 스프라이트 교체 |
| **UI 애니메이션** | 슬라이더 위치 자동 조정, HP 바 표시 |

### **🔧 데이터 관리 및 최적화**

| 구분 | 내용 |
|:-----|:-----|
| **ScriptableObject** | `TowerTemplate` - 타워 데이터의 구조화된 관리 |
| **Serializable 구조체** | `Wave` - 인스펙터에서 편집 가능한 웨이브 데이터 |
| **프로퍼티 시스템** | getter/setter를 이용한 안전한 데이터 접근 |
| **오브젝트 풀링** | 적과 투사체의 생성/제거 최적화 |
| **거리 기반 타겟팅** | 범위 내 가장 가까운 적을 우선 공격 |

### **🎮 입력 및 카메라 시스템**

| 구분 | 내용 |
|:-----|:-----|
| **마우스 입력** | `ObjectFollowMouse.cs` - 마우스 위치 추적 및 오브젝트 이동 |
| **키보드 입력** | ESC 키를 이용한 타워 배치 취소 시스템 |
| **카메라 제어** | `CameraComponent.cs` - 줌 인/아웃, 마우스 기반 이동 |
| **스크린 좌표 변환** | `ScreenToWorldPoint`, `ScreenToViewportPoint` 활용 |

### **📊 디버깅 및 테스트**

| 구분 | 내용 |
|:-----|:-----|
| **Unity Inspector** | SerializeField를 이용한 실시간 값 조정 |
| **Console 로그** | 디버그 정보 출력 및 에러 추적 |
| **Scene 뷰** | 게임 오브젝트 배치 및 관계 확인 |
| **코드 구조화** | 명확한 네이밍 컨벤션과 주석 처리 |

### **🚀 확장성 및 유지보수**

| 구분 | 내용 |
|:-----|:-----|
| **모듈화 설계** | 각 기능별 독립적인 컴포넌트 구조 |
| **인터페이스 설계** | 확장 가능한 무기 시스템 (캐논, 레이저, 슬로우, 버프) |
| **데이터 분리** | 게임 로직과 데이터의 분리로 유지보수성 향상 |
| **코드 재사용** | `Movement2D`, `ObjectDetector` 등 범용 컴포넌트 |

---

## 📊 프로젝트 규모 및 성과

### **📈 프로젝트 통계**
- **총 스크립트 파일**: 35개
- **핵심 시스템**: 8개
- **코드 라인**: 약 1,500+ 라인
- **개발 기간**: Unity 입문자 기준 2-3개월
- **완성도**: 완전한 게임 루프 구현

### **🎯 학습 성과**
- Unity의 핵심 기능들을 종합적으로 활용
- 게임 개발의 기본부터 고급 기법까지 폭넓게 학습
- C# 프로그래밍의 실전 활용 능력 향상
- 게임 시스템 설계 및 구현 경험 축적

### **🚀 주요 특징**
- **완전한 게임 루프 구현**
- **확장 가능한 시스템 아키텍처**
- **사용자 친화적인 UI/UX**
- **최적화된 성능과 안정성**

---

## 💡 핵심 인사이트

### **Unity의 철학**
> "GameObject는 껍데기, Component가 진짜 기능을 담당한다"

### **설계 원칙**
- **모듈화**: 각 기능별 독립적인 컴포넌트 구조
- **재사용성**: 범용 컴포넌트 설계
- **확장성**: 새로운 기능 추가가 용이한 구조
- **유지보수성**: 명확한 코드 구조와 네이밍 컨벤션

### **성장 포인트**
이 프로젝트를 통해 Unity 입문자에서 실전 게임 개발자로 성장할 수 있었습니다. 특히 컴포넌트 기반 설계와 C# 프로그래밍의 실전 활용 능력이 크게 향상되었습니다. 