---
title: 유니티3D - 1
date: 2025-05-23 15:00:00 +09:00
categories: [유니티,3D]
tags:
  [
    유니티, 3D
  ]
media_subpath: /assets/vod
---
## 목표
플레이어 캐릭터 생성, 이동 구현, 카메라 회전 제어, 간단한 애니메이션

## 플레이어 캐릭터 생성
게임 오브젝트에 Rigidbody 컴포넌트를 이용해서 캐릭터의 움직임을 만들려 했으나 CharacterController가 더 적합한 거 같아
CharacterController를 이용해 움직임을 만들겠다.
Rigidbody는 물리적객체(공, 수류탄)에 사용하는게 더 좋다고 생각하기 때문이다.

**Rigidbody의 변수 설명**
Mass - 질량 , Drag( 공기저항 ) - 떨어질 때 공기저항을 받아 값을 높일수록 깃털처럼 천천히 떨어진다.
Angular Drag ( 회전저항 ) - 값이 커질수록 더 회전하는데 오래걸림 , Use Gravity - 중력 사용여부
Is Kinematic - 활성화하면 다른 오브젝트?의 영향으로 물리학이 적용이 안됨 (밀기, 날리기) , Interpolate(물리계산) - 물리연산을 어떤식으로 보간할지 , Collsion Detection (충돌 체크) - 기본적인 충돌 감지 방식과 정적Collider와 충돌을 감지하는데 유리한 방식과 두 방식을 번갈아 사용하는 방식이 있다.
Constraints (회전, 위치 계산 설정) - 체크한 부분은 연산을 하지않는다. 내 생각엔 주로 Y축 회전만 사용하기떄문에 X,Z를 안써 연산량을 줄인다.

**FixedUpdate() 와 Update()**
UPdate() 함수는 매 프레임 호출 ( Time.deltatime 사용 ), FixedUpdate*() 고정된 시간으로 호출 ( Time.fixedDeltaTime 사용 )  
두 함수를 비교했을 때 캐릭터 이동 코드는 Update()가 맞다고 생각한다.  
프레임이 밀릴경우 더 많은 이동을 해야하는 상황도 나오느데 고정된 시간의 DeltaTime으로는 매꿀수없다고 생각하기 떄문이다.  
FixedUpdate()는 물리적 동기화를 사용할 때 좋은 것 같다. ex) Rigidbody를 이용한 물리 연산을 이용할 때  

**인풋 시스템**
언리얼과 비슷하게 InputAction 을 사용하여 사용자의 입력을 받아 처리할 것이다.
// 인풋액션 사진
Player 게임 오브젝트에 `Player Input` 컴포넌트를 추가한 후 Behavior를 `Invoke Unity Events`로 설정 한다.
그리고 이벤트 부분에 콜백함수를 바인딩 하여 실행시켜보았다.
// 바인딩 함수 부분 사진
하지만 실행되지 않아 디버깅을하여 바인딩된 함수가 제대로 호출되는지 확인했다.
역시나 함수가 호출되지 않았고 새로운 프로젝트를 만들어 유니티에서 제공되는 Inpuc Action으로 하여 실행하니 제대로 입력이 받아졌다.
그 후에 내가 만든 Input Action으로도 잘 실행이 되어 프로젝트 설정문제인가? 싶었다.
하지만 여기서 스키마를 추가하니 똑같은 문제가 발생하였고, 어? 하면서 유니티에서 만들어준 Input Action으로 바꾸어 해도 입력이 안받아졌다.  
스키마가 문제인걸 깨닫고 여기서 Device Type에 키보드를 추가하니 문제가 해결됐다.  
이 원인을 찾아내면서 신기한점은 다른 Input Action에도 영향이 가는게 무서운 점이였던 것  

## 인풋 시스템 주의점
디바이스 - 스키마 매칭이 **입력 전체 흐름에 영향을 미치는 구조**이다.  
하나의 스키마라도 디바이스가 누락되면 -> 프로젝트에 있는 모든 `PlayerInput`이 활성화되지 않아 입력이 들어오지 않는 문제가 발생  

## 캐릭터 이동과 회전
캐릭터 이동과 회전을 하기위해 PlayerController 컴포넌트에서 인풋 시스템에서 입력받은 액션을 제어하는 구조로 설계했다.
```c#
using UnityEngine;
using UnityEngine.InputSystem;

public class PlayerController : MonoBehaviour
{
    private CharacterMovement CharacterMovement;
    private CameraMovement CameraMovement;

    private void Awake()
    {
        CharacterMovement = GetComponent<CharacterMovement>();
        CameraMovement = GetComponentInChildren<CameraMovement>();
    }

    private void Start()
    {
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
    }

    public void OnMove(InputAction.CallbackContext context)
    {
        Vector2 input = context.ReadValue<Vector2>();
        CharacterMovement.SetMoveInput(input);
    }

    public void OnJump(InputAction.CallbackContext context)
    {
        if (context.performed)
        {
            CharacterMovement.Jump();
        }
    }

    public void OnLook(InputAction.CallbackContext context)
    {
        Vector2 input = context.ReadValue<Vector2>();
        CameraMovement.SetlookInput(input);
    }
}
```

**이동 구현, 카메라 회전 제어**
간단하게 캐릭터 컨트로러와 WASD로 받은 값으로 캐릭터의 X,Z 값을 변경시켰다.
카메라 회전 인풋을 받을 때 마우스 업할때 Y값은 -1이어야 한다. 즉 반대여야 우리가 원하는 대로 회전된다.  
그 이유는 카메라를 위로 회전하면 X축을 -값으로 올려야 하기 때문이다.
이 회전은 카메라를 회전시키지 않고 카메라를 포함하고있는 게임오브젝트를 부모로하여 언리얼의 SpringArm처럼 활용하였다.
```c#
    void Update()
    {
        rotX += lookInput.y * Sensitivity ;
        rotY += lookInput.x * Sensitivity ;

        rotX = Mathf.Clamp(rotX, -clamAngle, clamAngle);
        Quaternion rot = Quaternion.Euler(rotX, rotY, 0);
        transform.rotation = rot;
    }
```
여기서 카메라를 회전시킨 후 W키를 입력할 때 카메라 정면방향으로 움직이지 않았다.
그래서 카메라의 전방벡터와 라이트벡터를 가져와 방향을 설정해주었다. (SpringArm 때문에 카메라는 회전하지않아 전방벡터는 항상 내가 원하는 직진방향이다)  
```c#
 private void Update()
 {
     // 1. 입력 방향 계산 (카메라 기준)
     Vector3 moveDir = Camera.transform.right * moveInput.x + Camera.transform.forward * moveInput.y;
     moveDir.y = 0f;
     moveDir.Normalize();

     // 2. 수평 속도 처리 (XZ)
     if (moveDir.magnitude > 0.1f)
     {
         horizontalVelocity = Vector3.MoveTowards(horizontalVelocity, moveDir * maxSpeed, acceleration * Time.deltaTime);

         // 3. 회전 처리
         Quaternion toRotation = Quaternion.LookRotation(moveDir, Vector3.up);
         transform.rotation = Quaternion.Lerp(transform.rotation, toRotation, turnSpeed * Time.deltaTime);
     }
     else
     {
         horizontalVelocity = Vector3.MoveTowards(horizontalVelocity, Vector3.zero, deceleration * Time.deltaTime);
     }

     // 4. 중력 및 점프 처리 (Y)
     if (controller.isGrounded)
     {
         if (verticalVelocity < 0f)
             verticalVelocity = -1f; // 지면 안정화
     }
     else
     {
         verticalVelocity -= gravity * Time.deltaTime;
     }

     // 5. 최종 이동 벡터 조합
     Vector3 totalVelocity = horizontalVelocity;
     totalVelocity.y = verticalVelocity;

     controller.Move(totalVelocity * Time.deltaTime);
 }
```

## 애니메이션
일단 애니메이션컨트롤러를 생성한다. 언리얼의 애님클래스와 비슷한 역할인거 같다.  
그림과 같이 종료 시간 있음을 해제한다 이유는 True면 현재 진행중인 애니메이션을 끝까지 진행시킨 후 다음 애니메이션으로 넘어가기 때문이다.  
// 그림 사진
그리고 믹사모에서 YBot에 애니메이션을 가져왔다. 나는 다른 캐릭터를 사용할 것인데 여기서 문제는 애님 리타겟팅을 과정을 언리얼처럼 해야하는지 의문이다.  
일단 YBot 애니메이션이 있는 컨트롤러를 넣어주고 실행시켜본 결과 애님은 제대로 실행되어 보인다.  
일단 그럼 Idle -> Walk -> Run 을 하는 애니메이션 컨트롤러를 만들어보고 실행보겠다.
애니메이터에서 우클릭 후 Blend Tree를 만들어 단계별 애니메이션을 생성해보자. 언리얼의 블렌드 애니메이션과 비슷한 것 같다.
애님컨트롤러 스크립트를 만들고 캐릭터 무브먼트에서 수평이동의 벡터의 길이를 반환하여 애니메티어에 float "speed"값을 변경시켜 넣어주었다.
```c#
using UnityEngine;

public class AnimController : MonoBehaviour
{
    private Animator animator;
    private CharacterMovement characterMovement;

    private void Awake()
    {
        animator = GetComponent<Animator>();
        characterMovement = GetComponentInParent<CharacterMovement>();
    }

    void Update()
    {
        SetAinmSpeed();
    }

    void SetAinmSpeed()
    {
        float speed = characterMovement.GetAnimSpeed();
        animator.SetFloat("Speed", speed, 0.1f, Time.deltaTime);
    }
}

```
{% include embed/video.html src="걷기뛰기.mp4" title="걷기/뛰기 데모" %}

내가 원하는대로 동작이 되기는한다 시프트키를 누르기 전에 이동하면 걷고, 누르면 달리면서 잘 된다.  
하지만 카메라를 회전하거나 방향을 180도나 90도로 꺾을 때 부드럽지 않다.

#TODO
회전 할 때 감속 관리? 부드럽게 처리