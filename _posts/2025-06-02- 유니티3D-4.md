---
title: 유니티3D - 4
date: 2025-06-02 15:00:00 +09:00
categories: [유니티,3D]
tags:
  [
    유니티, 3D
  ]
---
## 이번 목표
TODO 리스트에 있는 감속과 애니메이션 회전을 마무리하고자한다.

### 감속, 방향전환 문제
일단 일어난 현상을 정리해 보자면 진행하는 방향에서 반대키를 누르면 감속이되면서 반대방향으로 가지는 현상이다.  
사실 현실적인 반대 방향 감속인거 같기는하다.  
좀 더 자연스럽게 처리하려면 멈추는 애니메이션을 추가하거나 게임 같게 반대로 바로 움직이는 것이다.  
반대로 바로 움직이는 방법으로 해결하겠다. 일단 코드에서 문제점을 찾아보자.  
MoveTowards 함수에서 현재 벡터와 목표 벡터방향으로 delta값을 곱하여 이동하기 때문이다. ex) 1 -> 0.5 -> 0 -> -0.5 -> - 1
```c#
horizontalVelocity = Vector3.MoveTowards(horizontalVelocity, moveDir * maxSpeed, acceleration * Time.deltaTime);
```
이것을 해결하려면 일단 감속하는 속도가 너무느린거 같기 떄문에 3번째 파라미터 값을 올리면 근본적으로 더 자연스럽게 해결될 것 같다.  
하지만 좋지 않은 방법인거 같다 그래서 생각한것은 그냥 현재 진행방향과 가고싶은방향을 비교하여 반대방향이면 제로벡터를 만들것이다.
이 방법을 사용해보니 이 방법 또한 좋지않았다는 것을 깨달았다. 다음 해결방안은 좀 더 생각해보고 해봐야겠다.  
MoveTowards() 함수를 이용하지않고 Lerp() 함수를 이용해서 전환하는 방법으로 해야겠다.
```c#
Vector3 targetVelocity = moveDir * maxSpeed;
horizontalVelocity = Vector3.Lerp(horizontalVelocity, targetVelocity, acceleration * Time.deltaTime);
```
확실히 방향전환에서 좀 더 자유로워졌다. 

### 애니메이션 방향문제
일단 언리얼처럼 애니메이션에셋자체 키프레임에 회전값을 변경시켜 해결하는 방법이 있나 찾아보았다.  
불가능한거 같다 유니티에서는 FPX 파일에서 임포트되면 Read-Only 애니메이션 클립인 것 이다.  
그래서 나는 그냥 에이밍할 때 메쉬 트랜스폼에서 y값을 회전시켜 보정해주기로 결정했다.  
```c#
    void OnAiming()
    {
        animator.SetBool("Aiming", true);
        targetWeight = 1f;
        isBlending = true;
        transform.localRotation = Quaternion.Euler(0f, 50f, 0f);
    }

    void OffAiming()
    {
        animator.SetBool("Aiming", false);
        targetWeight = 0f;
        isBlending = true;
        transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
    }
```
잘된다 하지만 처음에 localRotation으로 하지 않고 Rotation값을 했다가 Y축방향으로 계속 +50 되는 현상이 일어나는걸 보고 월드 좌표계에서 되는구나 하고 찾아냈다.  

{% include embed/video.html src="https://ooweaJ.github.io/assets/vod/회전조정.mp4" title="회전조정" %}

생각보다 간단한 문제들이였던것...  추가로 오늘은 총소리를 추가하고 끝내보도록해보자  

### 총소리 추가
일단 소리 재생시키기 위해서는 메인카메라에 Audio Listener 컴포넌트가 있어야한다 추가시켜줬다.
**AuidoClip**  
AudioClip은 재생하려는 소리 파일을 나타내는 클래스이고 WAV, MP3, OGG 등 다양한 형식의 오디오 파일을 지원합니다.

**AudioSource**
AudioSource 컴포넌트는 AudioClip을 재생하는 역할을 한다.  
AudioSource 에서 소리가 재생되어 3D사운드 설정, 볼륨 설정, 거리 설정, 등등을 해준다.  

```c#
   private void Awake()
   {
       data.source = GetComponent<AudioSource>();
       data.source.clip = data.GunShotClip;
       data.source.spatialBlend = 1f; // 3D사운드
       data.source.minDistance = 1f;
       data.source.maxDistance = 15f;
       data.source.volume = 0.5f;
   }
```

근데 처음에는 Start() 함수에서 실행했는데 null값이 나오는 것이였다. 그래서 Awaker()로 바꾸니까 잘 반영되었다.  
문제해결은 했지만 그 이유가 궁금해서 찾아봤다.  
직렬화 과정에서 Start() 보다 struct값이 먼저 덮어씌어져서 그럴수도 있다고했는데 이건 내가 Null값을 넣었을 때 현상이다.  
그래서 문제가 내가 실수를 했겠구나 하고 디버깅을 해보니 Start()함수자체가 호출이안되는거였다.  
아마 상속받은 자식클래스에서 Super콜을 하지않아서 그런거였다.  


