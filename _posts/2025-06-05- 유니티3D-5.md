---
title: 유니티3D - 5
date: 2025-06-05 15:00:00 +09:00
categories: [유니티,3D]
tags:
  [
    유니티, 3D
  ]
---
## 이번 목표
총 오토모드

### 오토모드 구조
일단 오토모드를 구현하기 위해서는 좌클릭을 눌렀을 때랑 땠을때를 구분할 수 있어야한다.  
context.canceled 를 이용해 웨폰컴포넌트에 OffAttack 함수를 만들어쉽게 구분이가능하다.  
```c#
    public void OnFire(InputAction.CallbackContext context)
    {
        if (context.performed)
        {
            weapon.L_Attack();
        }
        else if (context.canceled)
        {
            weapon.L_OffAttack();
        }
    }
```

그 후 GunWeapon에 OffFire() 함수를 추가하여 구현하도록 해주자.
```c#
    public void L_Attack()
    {
        if(Aiming)
        {
            CurrentWeapon.OnFire();
            OnFireEvent.Invoke();
        }
    }

    public void L_OffAttack()
    {
        CurrentWeapon.OffFire();
    }
```
원래 Onfire() 함수가 실행되면 바로 fire()함수가 실행하여 총을 쐈다. 하지만 이제 bool 타입 변수 firing으로 관리해줄것이다.  
코루틴함수를 이용해 연사를 구현하였다. 

```c#
    public void OnFire()
    {
        if (firing == true) return;
        firing = true;

        if (data.auto)
        {
            StartCoroutine("FireLoop");
        }
        else
        {
            fire();
        }
    }
    public void OffFire()
    {
        firing = false;
        if (data.auto)
        {
            StopCoroutine("FireLoop");
        }
    }

    private IEnumerator FireLoop()
    {
        while (true)
        {
            fire();
            yield return new WaitForSeconds(data.delayTime);
        }
    }
```
여기서 문제는 총을쏘는 애니메이션은 웨폰컴포넌트에 있는 델리게이트로 실행되기때문에 애니메이션은 작동되지않는다.  
유니티가 처음이라 일단 실행시키는데에 집중한 나머지 구조가 이상하게 되어있었다.
그리고 이 코드에서 문제점은 단발로 광클을하면 그게 더 빨리나간다 이 부분을 해결하기위해 새로운 bool 변수와 새로운 코루틴함수를 만들어서 관리했다.  
```c#

    public void OnFire()
    {
        if (firing == true) return;
        firing = true;

        if (data.auto)
        {
            StartCoroutine("FireLoop");
        }
        else
        {
            fire();
        }
       
    }
    public void OffFire()
    {
        firing = false;

        if (data.auto)
        {
            StopCoroutine("FireLoop");
        }
    }

    private IEnumerator FireLoop()
    {
        while (true)
        {
            fire();
            yield return new WaitForSeconds(data.delayTime);
        }
    }

    private IEnumerator FireTimer()
    {
        yield return new WaitForSeconds(data.delayTime);
        bCanFire = true;
    }

    // 추가한 부분
     public virtual void fire()
     {
       if (bCanFire == false) return;
       bCanFire = false;
       StartCoroutine("FireTimer");
     }
```
정리를 하자면 총을 쏘는 순간 (fire함수)에 CanFire를 false로만들고 코루틴함수로 딜레이타임이 지난후에 Canfire를 true로 만들어서 관리했다.  
그리고 애니메이션도 fire함수에서 실행하는게 맞는거 같다.  
애니메이션을 fire함수를 옮기던 와중에 나중에 총의 종류가 추가되는 구조에대해 생각해봤다. 
일단 GunWeapon에 델리게이트를 만들어 사용하는건 맞는거 같다.  
총의 종류가 추가된다면 델리게이트에 파라미터를 추가하여 전달해주어 애니메이션에서 Fire 트리거가 실행될 때 총기종류에따라 int값으로 분류하여 실행시키는 방법으로 생각해냈다.  
weaponcomponent에 있던 델리게이트를 GunWeapon에 옮겨서 바인드를 하는데 구조가 애님컨트롤러에 있는 CurrentWeapon에
WeaponComponent에 있는 CurrentWeapon을 가져와서 넣는 식으로 하려했는데 애님컨트롤러에 있는 CurrentWeapon이 Null이여서 바인딩(구독?)이 되지 않는거 같다.  
그리고 밑에 줄에 구독하는 코드들도 무시가 되는거 같다. 코드한줄 안바꿨는데 되던 델리게이트가 안됐다.  
그래서 무기를 장착 하는 타이밍에 구독을 해야 맞는거 같다.
AI 도 같은 컴포넌트를 이용해서 무기를 사용하고 할 것이다. 그래서 구조를 다시 완전히 크게 생각해봐야겠다.  